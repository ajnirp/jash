#!/home/rohanprinja/.rvm/bin/ruby-1.9.3-p448@global -W0

require 'readline'
require './colorize.rb'

# read from aliases file
$aliases = Hash[IO.readlines('aliases.txt').map(&:split)]

# parse bash aliases file
bash_aliases = IO.readlines(Dir.home + '/.bash_aliases').reject { |line| line.eql?("\n") || line =~ /^\s*#/ }.map { |line| line.rstrip.split("=",2) }
bash_aliases.map! { |k, v| [k.gsub(/alias /, '') , v[0] == "'" ? v[1...-1] : v] }

# programs in the PATH variable
# paths = ENV['PATH'].split ':'
# programs = []
# paths.each { |path| programs.concat(Dir.glob("#{path}/*").select { |file| File.executable? file }) }

# p programs

$fg_children = []

trap :INT do
  unless $fg_children.empty?
    Process.kill :USR1, $fg_children.last
    $fg_children.pop
  end
  puts; main
end

trap :USR1 do
  exit 1
end

$aliases.merge! Hash[bash_aliases]

$last_dir = Dir.pwd

def execute command
  if $aliases.include?(command)
    return fork_and_exec($aliases[command])
  end

  tokens = command.split
  if tokens.include? "&"
  end
  if tokens.include? "|"
  end

  command_name = tokens.first
  case command_name
  when "run", "cd", "cron", "parallel" then send command_name, tokens
  when "pwd" then puts Dir.pwd
  when "aliases" then show_aliases
  else fork_and_exec command
  end
end

def fork_and_exec command
  $fg_children << fork do
    exec command rescue puts "#{"Error:".red.bold} could not execute command `#{command.green}'"
  end
  Process.wait
  $fg_children.pop
end

def cd tokens
  if tokens.length == 1
    Dir.chdir # go to home directory
  else
    STDERR.puts "Ignoring multiple arguments to cd" if tokens.length > 2
    destination_dir = tokens[1]
    if destination_dir.eql? '-'
      destination_dir = $last_dir
      $last_dir = Dir.pwd
    end
    Dir.chdir destination_dir
  end
end

def show_aliases
  $aliases.each { |k, v| puts "#{k} is aliased to #{v}" }
end

def run tokens
  puts "fg"
end

def exit_shell
  $fg_children.each do |pid|
    Process.kill :USR1, pid
    $fg_children.pop
  end
  exit
end

# Readline.completion_append_character = ' '

def read_command
  prompt = "#{Dir.pwd} >>> ".blue
  line = Readline.readline prompt
  return nil if line.nil?
  unless line =~ /^\s*$/ or Readline::HISTORY.to_a.last == line
    Readline::HISTORY.push line
  end
  return line
end

username = `id -nu`
puts "Welcome, #{username}"
$stdout.flush

def main
  loop do
    command = read_command
    if command.nil?
      puts "\nBye!"
      exit_shell
    elsif command.empty?
      next
    end
    execute command
  end
end

main